<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chatbot V21.1 - B·ªô N√£o ƒêa NƒÉng</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f7f6;
            color: #333;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #chat-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        .message {
            margin-bottom: 10px;
            padding: 10px 15px;
            border-radius: 20px;
            max-width: 80%;
            word-wrap: break-word;
            line-height: 1.5;
        }
        .user {
            background-color: #007bff;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 5px;
        }
        .bot {
            background-color: #e9ecef;
            color: #333;
            align-self: flex-start;
            border-bottom-left-radius: 5px;
        }
        #input-container {
            display: flex;
            padding: 10px 20px;
            border-top: 1px solid #ddd;
            background-color: white;
        }
        #user-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 20px;
            margin-right: 10px;
            font-size: 16px;
        }
        button {
            padding: 10px 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #218838;
        }
        .header {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header button {
            background-color: #dc3545;
            padding: 5px 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div class="header">
        ü§ñ Chatbot V21.1 - B·ªô N√£o ƒêa NƒÉng
        <button id="clear-history">X√≥a L·ªãch S·ª≠ Chat</button>
    </div>

    <div id="chat-container"></div>

    <div id="input-container">
        <input type="text" id="user-input" placeholder="Nh·∫≠p c√¢u h·ªèi (!H·ªåC, !XEM, !DANHGON)">
        <button onclick="sendMessage()">G·ª≠i</button>
    </div>

    <script>
        let knowledge = {};

        // 1. T·∫£i ki·∫øn th·ª©c t·ª´ knowledge.json
        function loadKnowledge() {
            return fetch('knowledge.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    knowledge = data;
                    return true;
                })
                .catch(error => {
                    console.error("L·ªói t·∫£i ki·∫øn th·ª©c:", error);
                    appendMessage(`‚ö†Ô∏è**L·ªñI:** Kh√¥ng th·ªÉ t·∫£i ho·∫∑c ph√¢n t√≠ch file **knowledge.json**. Vui l√≤ng ki·ªÉm tra file ƒë√£ t·ªìn t·∫°i v√† ƒë√∫ng ƒë·ªãnh d·∫°ng JSON ch∆∞a. (S·ª≠ d·ª•ng ki·∫øn th·ª©c g·ªëc).`, 'bot');
                    return false;
                });
        }

        // 2. T·∫£i ki·∫øn th·ª©c t·ª´ Local Storage (b√†i h·ªçc ng∆∞·ªùi d√πng)
        function loadLocalStorage() {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('key_chuan_')) {
                    const originalKey = key.replace('key_chuan_', '');
                    knowledge[originalKey] = localStorage.getItem(key);
                }
            }
        }

        // 3. Kh·ªüi t·∫°o Chatbot
        async function initializeChatbot() {
            await loadKnowledge();
            loadLocalStorage();
            if (Object.keys(knowledge).length > 0) {
                 appendMessage("üëã Ch√†o b·∫°n! T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n h√¥m nay? H√£y nh·∫≠p t·ª´ kh√≥a ho·∫∑c d√πng l·ªánh **!H·ªåC**.", 'bot');
            }
        }

        // --- H√†m Ph·ª• Tr·ª£ ---
        function appendMessage(text, sender) {
            const container = document.getElementById('chat-container');
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${sender}`;
            
            // Chuy·ªÉn Markdown ƒë∆°n gi·∫£n th√†nh HTML
            text = text.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
            text = text.replace(/\n/g, '<br>');

            msgDiv.innerHTML = text;
            container.appendChild(msgDiv);
            container.scrollTop = container.scrollHeight; // Cu·ªôn xu·ªëng d∆∞·ªõi c√πng
        }

        function normalizeKey(text) {
            return text.toLowerCase().trim().replace(/\s+/g, '_');
        }

        // --- H√†m X·ª≠ l√Ω L·ªánh v√† Ph·∫£n h·ªìi ---
        async function handleCommand(command, message) {
            const parts = message.trim().split(/\s+/);
            const keyChuan = normalizeKey(message.replace(command, '').trim());

            switch (command) {
                case '!HOC':
                    if (keyChuan.includes('=')) {
                        const [key, value] = keyChuan.split('=').map(s => s.trim());
                        const originalValue = message.substring(message.indexOf('=') + 1).trim();

                        if (key && originalValue) {
                            localStorage.setItem('key_chuan_' + key, originalValue);
                            knowledge[key] = originalValue;
                            appendMessage(`‚ú® **ƒê√£ h·ªçc th√†nh c√¥ng!** T·ª´ kh√≥a **"${key}"** (Key chu·∫©n: **'key_chuan_${key}'**) ƒë√£ ƒë∆∞·ª£c l∆∞u Vƒ®NH VI·ªÑN (Local Storage) v·ªõi n·ªôi dung: "${originalValue}"`, 'bot');
                        } else {
                            appendMessage(`‚ö†Ô∏è **L·ªñI C√ö PH√ÅP!** Vui l√≤ng nh·∫≠p: **!HOC** [T·ª´ kh√≥a] = [N·ªôi dung h·ªçc]`, 'bot');
                        }
                    } else {
                         appendMessage(`‚ö†Ô∏è **L·ªñI C√ö PH√ÅP!** Vui l√≤ng nh·∫≠p: **!HOC** [T·ª´ kh√≥a] = [N·ªôi dung h·ªçc]`, 'bot');
                    }
                    break;

                case '!XEM':
                    if (parts.length > 1) {
                        const searchKey = normalizeKey(parts.slice(1).join(' '));
                        const keys = Object.keys(knowledge).filter(k => k.includes(searchKey));
                        if (keys.length > 0) {
                            let response = `üìú **PH·∫¢N H·ªíI KI·∫æN TH·ª®C:** T√¨m th·∫•y ${keys.length} t·ª´ kh√≥a li√™n quan ƒë·∫øn "${searchKey}":\n`;
                            keys.forEach(key => {
                                response += `\n**${key}**\n${knowledge[key].substring(0, 100)}...\n`;
                            });
                            appendMessage(response, 'bot');
                        } else {
                             appendMessage(`üßê T√¥i kh√¥ng t√¨m th·∫•y t·ª´ kh√≥a n√†o li√™n quan ƒë·∫øn **"${searchKey}"**.`, 'bot');
                        }
                    } else {
                         appendMessage(`‚ö†Ô∏è **L·ªñI C√ö PH√ÅP!** Vui l√≤ng nh·∫≠p: **!XEM** [T·ª´ kh√≥a mu·ªën t√¨m]`, 'bot');
                    }
                    break;

                case '!DANHGON':
                    // API Danh Ng√¥n m·ªõi, ƒë√£ s·ª≠a l·ªói v√† ho·∫°t ƒë·ªông ·ªïn ƒë·ªãnh
                    appendMessage(`‚è≥ ƒêang k·∫øt n·ªëi Internet...`, 'bot');
                    fetch('https://api.quotable.io/random')
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP Status: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            const quoteText = data.content; 
                            const author = data.author; 
                            const danhNgon = `üí° **DANH NG√îN NG·∫™U NHI√äN**\n"${quoteText}"\n‚Äî ${author}`;
                            appendMessage(danhNgon, 'bot');
                        })
                        .catch(error => {
                            appendMessage(`**‚ö†Ô∏è L·ªñI K·∫æT N·ªêI INTERNET:** Kh√¥ng th·ªÉ t·∫£i danh ng√¥n. Vui l√≤ng ki·ªÉm tra l·∫°i k·∫øt n·ªëi ho·∫∑c API. (L·ªói: ${error.message})`, 'bot');
                        });
                    break;

                default:
                    // X·ª≠ l√Ω l·ªánh kh√¥ng x√°c ƒë·ªãnh
                    break;
            }
        }

        function handleQuestion(message) {
            const keyChuan = normalizeKey(message);
            const foundKey = Object.keys(knowledge).find(key => keyChuan.includes(key));
            
            if (foundKey) {
                // Ph·∫£n h·ªìi t√¨m th·∫•y
                setTimeout(() => {
                    appendMessage(`üí° **PH·∫¢N H·ªíI KI·∫æN TH·ª®C**\n${knowledge[foundKey]}`, 'bot');
                }, 100);
            } else {
                // Ph·∫£n h·ªìi kh√¥ng t√¨m th·∫•y
                setTimeout(() => {
                    appendMessage(`T√¥i kh√¥ng t√¨m th·∫•y ki·∫øn th·ª©c v·ªÅ **"${message}"**. Vui l√≤ng nh·∫≠p **t·ª´ kh√≥a ch√≠nh x√°c** (ho·∫∑c th·ª≠ bi·∫øn th·ªÉ kh√¥ng d·∫•u) ho·∫∑c d√πng l·ªánh **!H·ªåC** ƒë·ªÉ d·∫°y t√¥i ki·∫øn th·ª©c n√†y.`, 'bot');
                }, 100);
            }
        }

        function sendMessage() {
            const input = document.getElementById('user-input');
            const message = input.value.trim();
            if (!message) return;

            appendMessage(message, 'user');
            input.value = '';

            const commandMatch = message.match(/^!(\w+)/i);

            if (commandMatch) {
                handleCommand(commandMatch[0].toUpperCase(), message);
            } else {
                handleQuestion(message);
            }
        }

        // --- X·ª≠ l√Ω s·ª± ki·ªán ---
        document.getElementById('user-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        document.getElementById('clear-history').addEventListener('click', function() {
            if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën X√ìA T·∫§T C·∫¢ L·ªäCH S·ª¨ chat (bao g·ªìm c·∫£ c√°c b√†i h·ªçc ƒë√£ h·ªçc)?')) {
                localStorage.clear();
                window.location.reload(); // T·∫£i l·∫°i trang ƒë·ªÉ x√≥a kh·ªèi b·ªô nh·ªõ
            }
        });

        // Kh·ªüi ƒë·ªông Chatbot
        initializeChatbot();

    </script>

</body>
</html>